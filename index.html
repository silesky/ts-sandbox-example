<!DOCTYPE html>
<html lang="en">

<head>
  <title>Trigger Functions</title>
  <meta charset="utf-8" />
  <link href="
  https://cdn.jsdelivr.net/npm/getskeleton@2.0.4-2/lib/css/skeleton.min.css
  " rel="stylesheet">
</head>
<div id="loader">Loading...</div>
<h2>Trigger Function Editor</h2>
<div id="monaco-editor-embed" style="height: 500px;" />
<script>
  // First set up the VSCode loader in a script tag
  const getLoaderScript = document.createElement('script')
  getLoaderScript.src = 'https://www.typescriptlang.org/js/vs.loader.js'
  getLoaderScript.async = true
  getLoaderScript.onload = () => {
    // Now the loader is ready, tell require where it can get the version of monaco, and the sandbox
    // This version uses the latest version of the sandbox, which is used on the TypeScript website

    // For the monaco version you can use unpkg or the TypeSCript web infra CDN
    // You can see the available releases for TypeScript here:
    // https://typescript.azureedge.net/indexes/releases.json
    //
    require.config({
      paths: {
        vs: 'https://typescript.azureedge.net/cdn/4.0.5/monaco/min/vs',
        // vs: 'https://unpkg.com/@typescript-deploys/monaco-editor@4.0.5/min/vs',
        sandbox: 'https://www.typescriptlang.org/js/sandbox',
      },
      // This is something you need for monaco to work
      ignoreDuplicateModules: ['vs/editor/editor.main'],
    })

    // Grab a copy of monaco, TypeScript and the sandbox
    require(['vs/editor/editor.main', 'vs/language/typescript/tsWorker', 'sandbox/index'], (
      main,
      _tsWorker,
      sandboxFactory
    ) => {
      const initialCode =
        `const triggerFn: TriggerFn = (signal) => {
  if (signal.type === 'Navigation') {
      signal.data.url // can safely access WebNavigationData here

  } else if (signal.type === 'UIInteraction') {
      signal.data.control  // can safely access WebContralData here
  }
}
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


    type SignalType = 'UIInteraction' | 'Navigation' | 'Network' | 'Instrumentation' | 'UserDefined'

    interface RawSignal<T> {
        anonymousId: string
        type: SignalType
        data: T
    }

   interface WebNavigationData {
        url: string
        pathname: string
        referrer: string
    }

    interface WebContralData {
        control: string
        info: string
    }

    interface WebNavigationSignal extends RawSignal<WebNavigationData> {
        type: 'Navigation'
    }

    interface UIInteractionSignal extends RawSignal<WebContralData> {
        type: 'UIInteraction'
    }
    
    

    type Signals = WebNavigationSignal | UIInteractionSignal
  
    interface SegmentEvent {
      type: string
    }

    interface SignalCtx {
      find(fromSignal: RawSignal<any>| undefined, signalType: SignalType, predicate: (s:RawSignal<any>) => boolean): RawSignal<any>| undefined
      add(signal:RawSignal<any>): void
    }
    
    interface TriggerFn {
      (signal: Signals, ctx: SignalCtx): void
    }
    
   import { AnalyticsSnippet } from "@segment/analytics-next"
   declare const analytics: AnalyticsSnippet
`

      const isOK = main && window.ts && sandboxFactory
      if (isOK) {

        document.getElementById('loader').parentNode.removeChild(document.getElementById('loader'))



      } else {
        console.error('Could not get all the dependencies of sandbox set up!')
        console.error('main', !!main, 'ts', !!window.ts, 'sandbox', !!sandbox)
        return
      }


      const sandboxConfig = {
        text: initialCode,
        domID: 'monaco-editor-embed',
      }

      const sandbox = sandboxFactory.createTypeScriptSandbox(sandboxConfig, main, window.ts)
      const editor = sandbox.editor
      const model = sandbox.getModel()

      var tsProxy
      monaco.languages.typescript.getTypeScriptWorker()
        .then((worker) => {
          worker(model.uri)
            .then((proxy) => {
              tsProxy = proxy;
            });
        });

      model.onDidChangeContent(() => {
        tsProxy.getSemanticDiagnostics(model.uri.toString()).then(diagnostics => {
          diagnostics.forEach(diag => {
            console.warn('TS Error:', diag.messageText);
          })
        })
        tsProxy.getEmitOutput(model.uri.toString())
          .then((r) => {
            // log compiled code
            console.log('compiled', r.outputFiles[0].text);
            // show compiled code in html
            const codeBlock = document.getElementById('compiled-code')
            if (codeBlock) {
              codeBlock.innerText = r.outputFiles[0].text
            }

          });
      })


      editor.focus()
    })
  }

  document.body.appendChild(getLoaderScript)

  // {
  //   // create compiled code
  //   const element = document.createElement('pre')
  //   element.setAttribute('id', 'compiled-code')
  //   document.body.appendChild(element)
  // }
</script>